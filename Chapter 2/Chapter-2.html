<!DOCTYPE html>
<html lang="" xml:lang="">
  <head>
    <title>Control Statements and Programming with functions</title>
    <meta charset="utf-8" />
    <meta name="author" content="Yebelay Berehan  Biostatistician " />
    <meta name="date" content="2022-05-21" />
    <script src="Chapter-2_files/header-attrs/header-attrs.js"></script>
    <link rel="stylesheet" href="xaringan-themer.css" type="text/css" />
  </head>
  <body>
    <textarea id="source">
class: center, middle, title-slide

.title[
# <p><span style="color:orange">Control Statements and Programming with functions</span></p>
]
.author[
### Yebelay Berehan <br><span style="font-size: 50%;">Biostatistician </span>
]
.institute[
### <p><a href="yebelay.ma@gmail.com"><span style="font-size: 80%;"> <span style="color:cyan">yebelay.ma@gmail.com</span></span></a></p>
]
.date[
### 2022-05-21
]

---



<div>
<style type="text/css">.xaringan-extra-logo {
width: 90px;
height: 85px;
z-index: 0;
background-image: url(Rlogo.png);
background-size: contain;
background-repeat: no-repeat;
position: absolute;
top:1em;right:1em;
}
</style>
<script>(function () {
  let tries = 0
  function addLogo () {
    if (typeof slideshow === 'undefined') {
      tries += 1
      if (tries < 10) {
        setTimeout(addLogo, 100)
      }
    } else {
      document.querySelectorAll('.remark-slide-content:not(.title-slide):not(.inverse):not(.hide_logo)')
        .forEach(function (slide) {
          const logo = document.createElement('div')
          logo.classList = 'xaringan-extra-logo'
          logo.href = null
          slide.appendChild(logo)
        })
    }
  }
  document.addEventListener('DOMContentLoaded', addLogo)
})()</script>
</div>




# &lt;span style="color:blue"&gt; Outlines&lt;/span&gt;

2.1. Conditional and Repetitive executions

2.1.1. if statements

2.1.2. for, while, and repeat loops

2.2. Function definition
---

## Bad Repetition

- If someone doesn't know better, they might find the means of variables in the swiss data by typing in a line of code for each column:


```r
mean1 &lt;- mean(swiss$Fertility)
mean2 &lt;- mean(swiss$Agriculture)
mean3 &lt;- mean(swissExamination)
mean4 &lt;- mean(swiss$Fertility)
mean5 &lt;- mean(swiss$Catholic)
mean5 &lt;- mean(swiss$Infant.Mortality)
*c(mean1, mean2 mean3, mean4, mean5, man6)
```

**Can you spot the problems?**

How upset would they be if the swiss data had 200 columns instead of 6?

---

## Good Repetition


```r
swiss_means &lt;- setNames(numeric(ncol(swiss)), colnames(swiss))
for(i in seq_along(swiss)) {
    swiss_means[i] &lt;- mean(swiss[[i]])
}
swiss_means
```

```
##        Fertility      Agriculture      Examination        Education 
##         70.14255         50.65957         16.48936         10.97872 
##         Catholic Infant.Mortality 
##         41.14383         19.94255
```

- 'setNames()' adds `names` (second argument) to its first argument.
- `numeric()` creates a numeric vector of length equal to its first argument.

**What is the use Repetition**

- Writing code to repeat tasks for us reduces the most common human coding mistakes.

- It also substantially reduces the time and effort involved in processing large volumes of data.

- Lastly, compact code is more readable and easier to troubleshoot.

---

## Conditional Flow

**`if()` then `else`**

- You've seen `ifelse()` before for logical checks on a whole vector.

- For checking whether a single logical statement holds and then conditionally executing a set of actions, use `if()` and `else:`


```r
for(i in 1:10) {
  if(i %% 2 == 0) { # %% gets remainder after division
    print(paste0("The number ", i, " is even."))
  } else if(i %% 3 == 0) {
    print(paste0("The number ", i, " is divisible by 3."))
  } else {
    print(paste0("The number ", i, " is not divisible by 2 or 3."))
  }
}
```

- Warning! else needs to be on same line as the closing brace `}` of previous `if()`.

---

## The for() Loop

- `for()` loops are the most general kind of loop, found in pretty much every programming language.

- For each of these values—in order—do this

*Conceptually:*

- Given a set of values...

1. You set an index variable (often `i`) equal to the first value

1. Do some set of things (usually depending on current value)

1. Is there a next value?

   - `YES:` Update to next value, go back to 2.
   - `NO:` Exit loop

- We are looping through values and repeating some actions.
---

## for() Loop: Diagram

![loop](forloop.png)

---

- `for()` Loop: Example

```r
for(i in 1:10) {
    # inside for, output won't show up without print()
    print(i^2) 
}
```

- Note this runs 10 separate print commands, which is why each line starts with [1].

- These Do the Same Thing
.pull-left[

```r
for(i in 1:3) {
    print(i^2) 
}
```

```
## [1] 1
## [1] 4
## [1] 9
```
]
.pull-right[

```r
i &lt;- 1
print(i^2) 
i &lt;- 2
print(i^2)
i &lt;- 3
print(i^2)
```
]

---

## Iteration Conventions

- We call what happens in the loop for a particular value one iteration.
- Iterating over indices `1:n` is very common.

- `n` might be the length of a vector, the number of rows or columns in a matrix or data frame, or the length of a list.
- **Common notation:** `i` is the object that holds the current value inside the loop.

- If loops are nested, you will often see `j` and `k` used for the inner loops.

- This notation is similar to indexing in mathematical symbols (e.g  `\(\sum_{i=1}^n)\)`

- Note `i` (and `j`,`k`, etc) are just normal objects. You can use any other names you want.

---

## Iterate Over Characters

- What we iterate over doesn't have to be numbers `1:n` or numbers at all! You can also iterate over a character vector in R:


```r
some_letters &lt;- letters[4:6] # Vector of letters d,e,f
for(i in some_letters) {
    print(i)
}
```

```
## [1] "d"
## [1] "e"
## [1] "f"
```

```r
i # in R, this will exist outside of the loop!
```

```
## [1] "f"
```

---

## `seq_along()` and Messages

- `seq_along(x)` creates an integer vector equal to `1:length(x)`.

- When you want to loop over something that isn't numeric but want to use a numeric index of where you are in the loop, `seq_along` is useful:


```r
for(a in seq_along(some_letters)) {
    print(paste0("Letter ", a, ": ", some_letters[a]))
}
```

```
## [1] "Letter 1: d"
## [1] "Letter 2: e"
## [1] "Letter 3: f"
```

```r
a # The object a contains the number of the last iteration
```

```
## [1] 3
```

---

## `while()` Loops

- A lesser-used looping structure is the `while()` loop.

- Rather than iterating over a predefined vector, the loop keeps going until some condition is no longer true.

- Let's see how many times we need to flip a coin to get `4` heads:


```r
num_heads &lt;- 0
num_flips &lt;- 0
while(num_heads &lt; 4) {
  coin_flip &lt;- rbinom(n = 1, size = 1, prob = 0.5)
  if (coin_flip == 1) { num_heads &lt;- num_heads + 1 }
  num_flips &lt;- num_flips + 1
}
num_flips # follows negative binomial distribution
```

```
## [1] 7
```

---

# Writing Functions

### Why Write Your Own Functions?

- Functions can encapsulate actions you might perform often, such as:
 
  - Given a vector, compute some special summary stats

  - Given a vector and definition of `invalid` values, replace with NA

  - Templates for favorite ggplots used in reports

  - Defining a new logical operator

---

## Creating functions

- Creating functions in R is pretty simple: we assign a function to a variable, just like any other variable assignment:


```r
my_fn &lt;- function(x) {
  2 * x
}
```

- a function is made up of arguments(the bit between the parentheses) and the body (the bit between the curly brackets).

- The last executed expression is returned from the function


```r
my_fn(3)
```

```
## [1] 6
```

---

- arguments are like variables that we can specify when we *call* the function.

- a function can have 0 arguments, or many arguments

.pull-left[

```r
my_fn &lt;- function() {
  3
}
my_fn()
```

```
## [1] 3
```
]
.pull-right[

```r
my_fn &lt;- function(x, y) {
  x + y
}
my_fn(3, 2)
```

```
## [1] 5
```
]

- a function can be **variadic** by specifying a ... argument, this is somewhat outside of the scope for today, but allows you to create functions with a variable number of arguments. 

- Often in R this is used to provide arguments that are passed to other functions.


```r
function(x, y, ...) {
  other_function(...)
}
```

```
## function(x, y, ...) {
##   other_function(...)
## }
```

---

- The body of the function can be split over multiple lines of code. It's common to include flow-control statements within a function, e.g.

- `if` and `else` statements
- `for` and `while` loops
- `stop` statements (used to produce an **error** message)
- `return` statements (immediately exits the function returning a given value)

.pull-left[


```r
my_fn &lt;- function(x) {
  if (x &gt; 10) {
    stop ("x is too big!")
  } else if (x &gt; 5) {
    return (x*2)
  }
  y &lt;- x - 1
  for (i in 1:5) {
    y &lt;- y*2
  }
  y
}
```
]
.pull-right[


```r
my_fn(2)
```

```
## [1] 32
```

```r
my_fn(5)
```

```
## [1] 128
```

```r
my_fn(6)
```

```
## [1] 12
```

```r
my_fn(10)
```

```
## [1] 20
```
]

---

## function argument/variable scope

- the values that are used in the function only exist in the function: we can't use them outside of the function


```r
my_fn &lt;- function(x) {
  y &lt;- 2 * x
  c(exists("x"), exists("y"))
}
my_fn(3)
```

```
## [1] TRUE TRUE
```

```r
c(exists("x"), exists("y"))
```

```
## [1] FALSE FALSE
```

---

- we can access variables that are defined outside of the function, but we can't modify them

```r
v &lt;- 8
my_fn &lt;- function(x) {
  y &lt;- 2 * x
  v &lt;- v - 1
  y + v
}
my_fn(3)
```

```
## [1] 13
```


- Now, inside the function call we decreased the value of v, but if we look at what value v has now we will see it hasn't changed


```r
v
```

```
## [1] 8
```

- R has created a new version of v inside the function and updated that value.

---


## default arguments

- you can specify default values for arguments: an argument with a default value does not have to be specified when you call the function


```r
my_fn &lt;- function(x, y = 3) {
  x + y
}
my_fn(4)
```

```
## [1] 7
```

- In this case we only passed a value for `x (4)`, y defaulted to *3*. But you can provide values, like so


```r
my_fn(4, 5)
```

```
## [1] 9
```

---

## argument order

- by default, the arguments are evaluated in order (x, then y). 

- But, you can specify them in any order if you provide the name of the argument.


```r
my_fn(y = 5, x = 4)
```

```
## [1] 9
```

```r
my_fn(y = 5, 4)
```

```
## [1] 9
```

---

## Using functions like variables

- because functions are just variables, you are able to pass functions as arguments to other functions


```r
f &lt;- function(values, fn) {
  fn(values)
}
f(c(1, 2, 5, 8), mean)
```

```
## [1] 4
```

```r
f(c(1, 2, 5, 8), median)
```

```
## [1] 3.5
```

- note, here the functions are passed without the parentheses:  we are passing the function, not the result of evaluating the function





    </textarea>
<style data-target="print-only">@media screen {.remark-slide-container{display:block;}.remark-slide-scaler{box-shadow:none;}}</style>
<script src="https://remarkjs.com/downloads/remark-latest.min.js"></script>
<script>var slideshow = remark.create({
"highlightLines": true,
"ratio": "14:9",
"highlightSpans": true,
"highlightStyle": "tomorrow-night-bright",
"countIncrementalSlides": false
});
if (window.HTMLWidgets) slideshow.on('afterShowSlide', function (slide) {
  window.dispatchEvent(new Event('resize'));
});
(function(d) {
  var s = d.createElement("style"), r = d.querySelector(".remark-slide-scaler");
  if (!r) return;
  s.type = "text/css"; s.innerHTML = "@page {size: " + r.style.width + " " + r.style.height +"; }";
  d.head.appendChild(s);
})(document);

(function(d) {
  var el = d.getElementsByClassName("remark-slides-area");
  if (!el) return;
  var slide, slides = slideshow.getSlides(), els = el[0].children;
  for (var i = 1; i < slides.length; i++) {
    slide = slides[i];
    if (slide.properties.continued === "true" || slide.properties.count === "false") {
      els[i - 1].className += ' has-continuation';
    }
  }
  var s = d.createElement("style");
  s.type = "text/css"; s.innerHTML = "@media print { .has-continuation { display: none; } }";
  d.head.appendChild(s);
})(document);
// delete the temporary CSS (for displaying all slides initially) when the user
// starts to view slides
(function() {
  var deleted = false;
  slideshow.on('beforeShowSlide', function(slide) {
    if (deleted) return;
    var sheets = document.styleSheets, node;
    for (var i = 0; i < sheets.length; i++) {
      node = sheets[i].ownerNode;
      if (node.dataset["target"] !== "print-only") continue;
      node.parentNode.removeChild(node);
    }
    deleted = true;
  });
})();
// add `data-at-shortcutkeys` attribute to <body> to resolve conflicts with JAWS
// screen reader (see PR #262)
(function(d) {
  let res = {};
  d.querySelectorAll('.remark-help-content table tr').forEach(tr => {
    const t = tr.querySelector('td:nth-child(2)').innerText;
    tr.querySelectorAll('td:first-child .key').forEach(key => {
      const k = key.innerText;
      if (/^[a-z]$/.test(k)) res[k] = t;  // must be a single letter (key)
    });
  });
  d.body.setAttribute('data-at-shortcutkeys', JSON.stringify(res));
})(document);
(function() {
  "use strict"
  // Replace <script> tags in slides area to make them executable
  var scripts = document.querySelectorAll(
    '.remark-slides-area .remark-slide-container script'
  );
  if (!scripts.length) return;
  for (var i = 0; i < scripts.length; i++) {
    var s = document.createElement('script');
    var code = document.createTextNode(scripts[i].textContent);
    s.appendChild(code);
    var scriptAttrs = scripts[i].attributes;
    for (var j = 0; j < scriptAttrs.length; j++) {
      s.setAttribute(scriptAttrs[j].name, scriptAttrs[j].value);
    }
    scripts[i].parentElement.replaceChild(s, scripts[i]);
  }
})();
(function() {
  var links = document.getElementsByTagName('a');
  for (var i = 0; i < links.length; i++) {
    if (/^(https?:)?\/\//.test(links[i].getAttribute('href'))) {
      links[i].target = '_blank';
    }
  }
})();
// adds .remark-code-has-line-highlighted class to <pre> parent elements
// of code chunks containing highlighted lines with class .remark-code-line-highlighted
(function(d) {
  const hlines = d.querySelectorAll('.remark-code-line-highlighted');
  const preParents = [];
  const findPreParent = function(line, p = 0) {
    if (p > 1) return null; // traverse up no further than grandparent
    const el = line.parentElement;
    return el.tagName === "PRE" ? el : findPreParent(el, ++p);
  };

  for (let line of hlines) {
    let pre = findPreParent(line);
    if (pre && !preParents.includes(pre)) preParents.push(pre);
  }
  preParents.forEach(p => p.classList.add("remark-code-has-line-highlighted"));
})(document);</script>

<script>
slideshow._releaseMath = function(el) {
  var i, text, code, codes = el.getElementsByTagName('code');
  for (i = 0; i < codes.length;) {
    code = codes[i];
    if (code.parentNode.tagName !== 'PRE' && code.childElementCount === 0) {
      text = code.textContent;
      if (/^\\\((.|\s)+\\\)$/.test(text) || /^\\\[(.|\s)+\\\]$/.test(text) ||
          /^\$\$(.|\s)+\$\$$/.test(text) ||
          /^\\begin\{([^}]+)\}(.|\s)+\\end\{[^}]+\}$/.test(text)) {
        code.outerHTML = code.innerHTML;  // remove <code></code>
        continue;
      }
    }
    i++;
  }
};
slideshow._releaseMath(document);
</script>
<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
(function () {
  var script = document.createElement('script');
  script.type = 'text/javascript';
  script.src  = 'https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-MML-AM_CHTML';
  if (location.protocol !== 'file:' && /^https?:/.test(script.src))
    script.src  = script.src.replace(/^https?:/, '');
  document.getElementsByTagName('head')[0].appendChild(script);
})();
</script>
  </body>
</html>
